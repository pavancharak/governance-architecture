{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home Governance System : Canonical Index This repository contains the complete canonical specification of the governance system. These documents define a regulated, deterministic, human-governed decision platform. All system behavior, logic, and evolution must be derivable from these files. No other source of truth exists. Document Map Foundational, non-negotiable laws of the system. These are the mathematical and philosophical invariants. Nothing in any other document may contradict them. Defines what kinds of entities exist in the system. This is the closed ontology of reality. If something is not defined here, it does not exist. Defines the canonical record types. This is the formal grammar of truth. It specifies exactly what may be written to the registry. Defines execution semantics. This describes how the system runs, evaluates logic, and produces decisions. Defines human-in-the-loop governance. This describes how human authority enters the system and how it is recorded. The full system constitution. This integrates all principles into a single coherent formal model. Concrete example executions. This shows how the abstract system behaves in practice. Formal schemas for canonical records. This defines the precise structure and constraints of all records. Authority Model These documents are authoritative. All system implementations, code, APIs, user interfaces, and tools must conform to them. No behavior is permitted unless it is explicitly justified by these specifications. Change Policy These documents are immutable. Any change must be proposed via a formal ChangeSet and approved by humans. No document may be modified directly without explicit governance. Intended Usage This specification is intended to be used by: System designers. Auditors and reviewers. Human decision-makers. AI systems acting as compilers, simulators, or analysts. AI systems must treat these documents as the only source of truth. If something is not defined here, it must be treated as undefined. Final Principle The system is governed by humans. The system enforces truth. AI assists, but never decides.","title":"Home"},{"location":"#home","text":"Governance System : Canonical Index This repository contains the complete canonical specification of the governance system. These documents define a regulated, deterministic, human-governed decision platform. All system behavior, logic, and evolution must be derivable from these files. No other source of truth exists. Document Map Foundational, non-negotiable laws of the system. These are the mathematical and philosophical invariants. Nothing in any other document may contradict them. Defines what kinds of entities exist in the system. This is the closed ontology of reality. If something is not defined here, it does not exist. Defines the canonical record types. This is the formal grammar of truth. It specifies exactly what may be written to the registry. Defines execution semantics. This describes how the system runs, evaluates logic, and produces decisions. Defines human-in-the-loop governance. This describes how human authority enters the system and how it is recorded. The full system constitution. This integrates all principles into a single coherent formal model. Concrete example executions. This shows how the abstract system behaves in practice. Formal schemas for canonical records. This defines the precise structure and constraints of all records. Authority Model These documents are authoritative. All system implementations, code, APIs, user interfaces, and tools must conform to them. No behavior is permitted unless it is explicitly justified by these specifications. Change Policy These documents are immutable. Any change must be proposed via a formal ChangeSet and approved by humans. No document may be modified directly without explicit governance. Intended Usage This specification is intended to be used by: System designers. Auditors and reviewers. Human decision-makers. AI systems acting as compilers, simulators, or analysts. AI systems must treat these documents as the only source of truth. If something is not defined here, it must be treated as undefined. Final Principle The system is governed by humans. The system enforces truth. AI assists, but never decides.","title":"Home"},{"location":"architecture_v1/","text":"Architecture v1 Section 1 : Purpose & Scope Purpose The system is a regulated deterministic governance platform designed to serve as a foundational decision backbone for organizations and critical processes. Its purpose is to: Execute decision processes using only explicit, human-authored logic. Record all authoritative decisions as immutable, auditable facts. Provide full, reconstructable explanations for every decision. Enforce strong human authority over all system evolution. Act as a safe boundary between automated reasoning and real-world action. The system is intended to be used as: A Decision Backbone for structured decision-making. A Compliance Engine for enforceable governance rules. A Legal Memory for authoritative, non-repudiable records. A Safe AI Boundary where AI may assist in design and simulation but never act as an autonomous authority. Scope The system governs decision logic, not general computation. It is scoped to: Deterministic evaluation of predefined decision processes. Human-in-the-loop escalation where deterministic outcomes cannot be derived. Cryptographically verifiable recording of decisions and processes. Logical replay and reconstruction of past decisions for audit and explanation. The system operates under the principle that no outcome may be produced unless it is explicitly permitted by prior human-authored logic. Out of Scope The system does not: Perform open-ended optimization or inference. Learn or modify its own decision logic. Generate new rules, policies, or outcomes autonomously. Act as a general-purpose workflow engine. Execute real-world actions directly without human authorization. AI components may be used only for design assistance, simulation, and explanation. They are never a source of authority and never a source of truth. Authority Boundary The system itself is the authoritative source of internal truth. However: All system behavior is defined and controlled by humans. All changes to system logic require explicit human approval. The system enforces its own constraints and must fail closed if consistency or authority cannot be established. The system is governed by humans, but not mutable by humans without trace. Section 2 : Core Ontology (draft v1) Ontological Scope The system defines a closed and explicit ontology of internal entities. Only entities defined within this ontology are permitted to exist inside the system. No implicit, dynamic, or ad-hoc entity types are allowed. All entities are: First-class. Explicitly typed. Immutable once created. Identified by content-derived cryptographic identity. Classes of Entities The system\u2019s ontology consists of two fundamental classes: a) Factual Entities Factual entities represent what actually happened. They include records such as: Decisions made by the system. Execution steps taken during a process. Escalations and their resolutions. Operational events. Factual entities are historical truth. They are never edited, never deleted, and never reinterpreted. b) Definitional Entities Definitional entities represent the logic that governs system behavior. They include records such as: Decision points. Preconditions. Escalation rules. Intent skeletons. Schemas and record definitions. Definitional entities determine how future decisions may be evaluated. They do not retroactively affect past factual entities. Ontology Closure Principle The set of entity types in the system is strictly limited and closed. No new fundamental entity types may be introduced dynamically. Changes to the ontology itself are treated as system evolution and require the same human-approved change process as any other core logic change. Dual-Truth Principle The system treats both: Facts (what happened), and Process traces (how it happened) as equally real and first-class. Neither is derived from the other. Both are stored explicitly, immutably, and independently. Identity Principle Every entity in the system has a content-derived cryptographic identity. The identity is computed as a hash of the canonical serialization of the entity\u2019s contents. Any change to content produces a different identity. Tampering is detectable at the object level. Replay does not require trusting storage. Section 3 : Authority & Identity Model (draft v1) Authority Model The system operates under a strict human authority model. No internal component, automated process, or AI system is ever considered an authority. All authoritative decisions originate from humans and are recorded explicitly by the system. The system may evaluate logic and enforce constraints, but it never originates authority. Identity Model The system itself is the ultimate authority for internal identity. All human identities are: Created and managed inside the system. Authenticated using system-managed cryptographic keys. Verified using a single, consistent trust boundary. The system does not delegate identity verification to external authorities and does not mix multiple identity sources at runtime. Equality of Human Identities Within a single running system: All human identities are verified in exactly the same way. No human role is inherently trusted. All human actions are cryptographically signed and auditable. Roles define permissions, not trust. Non-Repudiation All authoritative human actions are: Cryptographically signed. Verifiable by the system. Non-repudiable. The system can always prove: Who performed an action. What action was performed. Under which logic version it was evaluated. Insider Threat Model The system\u2019s threat model includes: External attackers. Malicious insiders. Multiple insiders colluding. No human role is assumed to be benign by default. Security mechanisms must ensure: All actions are fully auditable. Tampering is detectable. No group of humans can silently subvert system truth. Section 4 : Registry & Event Store Model (draft v1) Source of Truth The system maintains a logically single registry as its authoritative source of truth. All canonical records exist only within this registry. No component outside the registry is considered a source of truth. Append-Only Semantics The registry is strictly append-only. Once a record is written: It is never modified. It is never deleted. It is never overwritten. All system evolution occurs only by appending new records. Logical Singularity, Physical Distribution The registry is physically distributed across multiple replicas for availability and resilience. However, it behaves as a logically single source of truth. If replicas diverge, disagree, or cannot establish consistency: The system must fail closed. No new records may be accepted. Processing must stop until consistency is restored. Multiple Typed Logs The registry is organized as multiple explicit append-only logs. Each log corresponds to a distinct class of record, such as: Decision events. Execution traces. Escalation records. Change sets. Operational records. Logs are logically separate but causally linked through explicit references. No single unified log is used for all record types. Registry Authority Rule The Decision Engine must never write canonical records directly. All creation of canonical records occurs only via the Registry Engine. The Decision Engine is an orchestrator, not a source of truth. Section 5 : Canonical Record Types (draft v1) Closed Set Principle The system defines a strictly limited and closed set of canonical record types. Only these record types are permitted to exist in the registry. No new fundamental record types may be introduced dynamically. Changes to the set of record types are treated as system evolution and require explicit human approval. Factual Record Types The system includes the following factual record types: DecisionEvent ExecutionTrace EscalationRecord OperationalRecord These represent what actually happened in the system. They are immutable, append-only, and content-hash identified. Definitional Record Types The system includes the following definitional record types: DecisionPoint Precondition EscalationRule IntentSkeleton ChangeSet These represent the logic and structure that govern future behavior. They are immutable, append-only, and content-hash identified. Schema Strictness All canonical record types have strict, fully normalized schemas. For each record type: Only explicitly defined fields are allowed. Unknown or extension fields are forbidden. Records with invalid schema are rejected. Referential Integrity All canonical records must reference only existing canonical records. Records containing invalid, missing, or inconsistent references are invalid and must be rejected. Validation and Consensus A canonical record is considered valid only if: Its schema is valid. All references are valid. All required signatures are valid. All replicas reach unanimous consensus. If any of these conditions fail, the record must not be accepted. Section 6 : Decision Semantics (draft v1) Decision Definition A decision is any authoritative determination made by the system at a defined decision point. Every decision is recorded as a DecisionEvent. There is no special distinction between intermediate and final decisions. All decisions are first-class. Deterministic Evaluation For any given input, the system may only apply predefined, human-authored logic. The system must never infer, optimize, or compute outcomes not explicitly specified. If no deterministic outcome can be derived from written logic, the system must escalate to human authority. Decision Event Structure A DecisionEvent includes: The decision point at which it occurred. The intent context under which it was evaluated. The outcome selected. A structured reason code chosen from a human-defined enum. A reference to the execution trace on which it is based. Cryptographic signatures. A DecisionEvent does not include: Free-text justification. Embedded data. Explicit timestamps. Identity of the decision-maker. Reason Codes Reason codes represent categories of justification. They are controlled, human-defined enums. They do not contain explanations themselves. Full explanations are derived from execution traces and definitional logic. Temporal Semantics A DecisionEvent does not contain an explicit timestamp. Temporal ordering is derived from: Append-only ledger position. Cryptographic signatures. Time is not stored as semantic content inside the decision itself. Section 7 : Execution & Replay Semantics (draft v1) Execution Model System execution is represented as a sequence of immutable execution traces. Each ExecutionTrace represents a single step or transition in a decision process. Execution is append-only and strictly ordered by causal links between traces. Trace Immutability Each ExecutionTrace: Is created once. Is never modified. Is never deleted. References the previous trace in the process. There is no single growing or mutable trace object. The full execution history is the chain of trace records. Replay Semantics Replay is purely logical and internal. Its purpose is to reconstruct: What the system believed. What decisions were made. How those decisions were reached. Replay must never: Re-trigger external actions. Cause any real-world side effects. Modify system state. Escalation Semantics Escalations are first-class governed processes. An escalation is represented by an EscalationRecord, which includes: The trigger trace. The escalation rule used. The assigned human authorities. The human resolution. The resulting decision event. The resolution trace. Escalations are not mere notifications. They are authoritative decision processes with recorded outcomes. Causal Consistency All execution traces, decisions, and escalations must form a causally consistent graph. No cycles are permitted. Section 8 : Intent & Process Model (draft v1) Intent Context An IntentContext represents a single decision process instance. It is a snapshot of all relevant state for that process. Once a decision process starts, its IntentContext is frozen. No mid-flight input may mutate it. Snapshot Isolation If new information arrives while a decision is pending: Either a new decision process is spawned with a new IntentContext, or The current process is aborted and restarted. Inputs are never merged into an active context. Intent Skeleton An IntentSkeleton defines the executable behavioral template for a class of processes. It specifies: Default stages. Allowed transitions. Linked decision points. Linked preconditions. Linked escalation rules. An IntentSkeleton is not merely a static ontology. It is a starter program for how an intent should be processed. Process Determinism Intent processing is fully deterministic. Given the same IntentSkeleton and the same IntentContext, the system must always produce the same sequence of traces and decisions. Task Semantics A task is a notification or instruction issued to a human. Tasks are not first-class entities with their own lifecycle. The system records that a task was issued and to whom. Task execution is reflected only through subsequent human decisions or actions. Section 9 : Change & Evolution Model (draft v1) Non-Retroactivity System logic changes must never retroactively affect past decisions. Every decision is evaluated only against the exact logic version that existed at the time the decision process started. ChangeSet Mechanism All changes to definitional logic must be proposed and compiled into a ChangeSet artifact. The runtime system ingests and applies only ChangeSets. Direct mutation of core definitions is forbidden. Human Approval Each ChangeSet requires explicit human approval before application. Automatic application is not allowed. Single Active Version At any given time, there is exactly one active version of system schemas and logic. Old versions are preserved only for historical reference and replay. Multiple active logic versions may not coexist at runtime. Immutable History Past definitions are never deleted. They remain in the registry as historical truth. System evolution is fully auditable. Section 10 : Security & Threat Model (draft v1) Threat Model The system assumes the presence of: External attackers. Malicious insiders. Faulty or compromised internal components. Multiple insiders colluding. No internal actor is inherently trusted. Auditability All actions in the system must be: Recorded. Cryptographically verifiable. Fully auditable. No action may occur without leaving an immutable trace. Tamper Detection Tampering with any canonical record must be detectable. Record identity and integrity are cryptographically bound. Replay does not require trusting storage. Fail-Closed Principle If the system cannot establish: Consistent registry state, or Valid authority, or Valid cryptographic verification, It must fail closed and stop processing. No Silent Authority No human or system component may perform authoritative actions without being recorded and signed. There is no concept of implicit trust. All authority is explicit and auditable. Section 11 \u2014 Deployment & Operational Model (draft v1) 1. Physical Distribution The system is physically distributed across multiple independent replicas. Each replica runs as a separate program or process. There is no single monolithic system instance. Logical Singularity Despite physical distribution, the system behaves as a logically single entity. All replicas must agree on all canonical records. There is exactly one authoritative system state. Consensus Requirement The system uses strong consensus with unanimous agreement. A record is considered valid only if all replicas explicitly agree. Temporary forks or divergent truths are not permitted. Failure Semantics If replicas: Diverge, Disagree, or Cannot reach unanimous consensus, The system must stop processing and wait until consistency is restored. Availability is always secondary to correctness. Operational Records Operational events, both human and system-generated, are recorded as OperationalRecords. These records are first-class, immutable, and auditable. They are subject to the same cryptographic and consensus guarantees as all other canonical records. Section 12 : Global Invariants (draft v1) Determinism Invariant For any given input and logic version, the system must always produce the same sequence of execution traces and decisions. No nondeterministic behavior is permitted. Authority Invariant No authoritative outcome may be produced without explicit human-defined logic and, where required, explicit human approval. AI components may never act as autonomous authorities. Non-Retroactivity Invariant Past decisions must never be re-evaluated or altered by future logic changes. Historical truth is immutable. Identity Invariant All actions must be attributable to verified system identities. Anonymous authority is forbidden. Content-Derived Identity Invariant Every canonical record must have a content-derived cryptographic identity. Any change to content must result in a different identity. Fail-Closed Invariant If any core invariant cannot be enforced, the system must stop processing. Partial correctness is forbidden.","title":"Architecture"},{"location":"architecture_v1/#architecture-v1","text":"Section 1 : Purpose & Scope Purpose The system is a regulated deterministic governance platform designed to serve as a foundational decision backbone for organizations and critical processes. Its purpose is to: Execute decision processes using only explicit, human-authored logic. Record all authoritative decisions as immutable, auditable facts. Provide full, reconstructable explanations for every decision. Enforce strong human authority over all system evolution. Act as a safe boundary between automated reasoning and real-world action. The system is intended to be used as: A Decision Backbone for structured decision-making. A Compliance Engine for enforceable governance rules. A Legal Memory for authoritative, non-repudiable records. A Safe AI Boundary where AI may assist in design and simulation but never act as an autonomous authority. Scope The system governs decision logic, not general computation. It is scoped to: Deterministic evaluation of predefined decision processes. Human-in-the-loop escalation where deterministic outcomes cannot be derived. Cryptographically verifiable recording of decisions and processes. Logical replay and reconstruction of past decisions for audit and explanation. The system operates under the principle that no outcome may be produced unless it is explicitly permitted by prior human-authored logic. Out of Scope The system does not: Perform open-ended optimization or inference. Learn or modify its own decision logic. Generate new rules, policies, or outcomes autonomously. Act as a general-purpose workflow engine. Execute real-world actions directly without human authorization. AI components may be used only for design assistance, simulation, and explanation. They are never a source of authority and never a source of truth. Authority Boundary The system itself is the authoritative source of internal truth. However: All system behavior is defined and controlled by humans. All changes to system logic require explicit human approval. The system enforces its own constraints and must fail closed if consistency or authority cannot be established. The system is governed by humans, but not mutable by humans without trace. Section 2 : Core Ontology (draft v1) Ontological Scope The system defines a closed and explicit ontology of internal entities. Only entities defined within this ontology are permitted to exist inside the system. No implicit, dynamic, or ad-hoc entity types are allowed. All entities are: First-class. Explicitly typed. Immutable once created. Identified by content-derived cryptographic identity. Classes of Entities The system\u2019s ontology consists of two fundamental classes: a) Factual Entities Factual entities represent what actually happened. They include records such as: Decisions made by the system. Execution steps taken during a process. Escalations and their resolutions. Operational events. Factual entities are historical truth. They are never edited, never deleted, and never reinterpreted. b) Definitional Entities Definitional entities represent the logic that governs system behavior. They include records such as: Decision points. Preconditions. Escalation rules. Intent skeletons. Schemas and record definitions. Definitional entities determine how future decisions may be evaluated. They do not retroactively affect past factual entities. Ontology Closure Principle The set of entity types in the system is strictly limited and closed. No new fundamental entity types may be introduced dynamically. Changes to the ontology itself are treated as system evolution and require the same human-approved change process as any other core logic change. Dual-Truth Principle The system treats both: Facts (what happened), and Process traces (how it happened) as equally real and first-class. Neither is derived from the other. Both are stored explicitly, immutably, and independently. Identity Principle Every entity in the system has a content-derived cryptographic identity. The identity is computed as a hash of the canonical serialization of the entity\u2019s contents. Any change to content produces a different identity. Tampering is detectable at the object level. Replay does not require trusting storage. Section 3 : Authority & Identity Model (draft v1) Authority Model The system operates under a strict human authority model. No internal component, automated process, or AI system is ever considered an authority. All authoritative decisions originate from humans and are recorded explicitly by the system. The system may evaluate logic and enforce constraints, but it never originates authority. Identity Model The system itself is the ultimate authority for internal identity. All human identities are: Created and managed inside the system. Authenticated using system-managed cryptographic keys. Verified using a single, consistent trust boundary. The system does not delegate identity verification to external authorities and does not mix multiple identity sources at runtime. Equality of Human Identities Within a single running system: All human identities are verified in exactly the same way. No human role is inherently trusted. All human actions are cryptographically signed and auditable. Roles define permissions, not trust. Non-Repudiation All authoritative human actions are: Cryptographically signed. Verifiable by the system. Non-repudiable. The system can always prove: Who performed an action. What action was performed. Under which logic version it was evaluated. Insider Threat Model The system\u2019s threat model includes: External attackers. Malicious insiders. Multiple insiders colluding. No human role is assumed to be benign by default. Security mechanisms must ensure: All actions are fully auditable. Tampering is detectable. No group of humans can silently subvert system truth. Section 4 : Registry & Event Store Model (draft v1) Source of Truth The system maintains a logically single registry as its authoritative source of truth. All canonical records exist only within this registry. No component outside the registry is considered a source of truth. Append-Only Semantics The registry is strictly append-only. Once a record is written: It is never modified. It is never deleted. It is never overwritten. All system evolution occurs only by appending new records. Logical Singularity, Physical Distribution The registry is physically distributed across multiple replicas for availability and resilience. However, it behaves as a logically single source of truth. If replicas diverge, disagree, or cannot establish consistency: The system must fail closed. No new records may be accepted. Processing must stop until consistency is restored. Multiple Typed Logs The registry is organized as multiple explicit append-only logs. Each log corresponds to a distinct class of record, such as: Decision events. Execution traces. Escalation records. Change sets. Operational records. Logs are logically separate but causally linked through explicit references. No single unified log is used for all record types. Registry Authority Rule The Decision Engine must never write canonical records directly. All creation of canonical records occurs only via the Registry Engine. The Decision Engine is an orchestrator, not a source of truth. Section 5 : Canonical Record Types (draft v1) Closed Set Principle The system defines a strictly limited and closed set of canonical record types. Only these record types are permitted to exist in the registry. No new fundamental record types may be introduced dynamically. Changes to the set of record types are treated as system evolution and require explicit human approval. Factual Record Types The system includes the following factual record types: DecisionEvent ExecutionTrace EscalationRecord OperationalRecord These represent what actually happened in the system. They are immutable, append-only, and content-hash identified. Definitional Record Types The system includes the following definitional record types: DecisionPoint Precondition EscalationRule IntentSkeleton ChangeSet These represent the logic and structure that govern future behavior. They are immutable, append-only, and content-hash identified. Schema Strictness All canonical record types have strict, fully normalized schemas. For each record type: Only explicitly defined fields are allowed. Unknown or extension fields are forbidden. Records with invalid schema are rejected. Referential Integrity All canonical records must reference only existing canonical records. Records containing invalid, missing, or inconsistent references are invalid and must be rejected. Validation and Consensus A canonical record is considered valid only if: Its schema is valid. All references are valid. All required signatures are valid. All replicas reach unanimous consensus. If any of these conditions fail, the record must not be accepted. Section 6 : Decision Semantics (draft v1) Decision Definition A decision is any authoritative determination made by the system at a defined decision point. Every decision is recorded as a DecisionEvent. There is no special distinction between intermediate and final decisions. All decisions are first-class. Deterministic Evaluation For any given input, the system may only apply predefined, human-authored logic. The system must never infer, optimize, or compute outcomes not explicitly specified. If no deterministic outcome can be derived from written logic, the system must escalate to human authority. Decision Event Structure A DecisionEvent includes: The decision point at which it occurred. The intent context under which it was evaluated. The outcome selected. A structured reason code chosen from a human-defined enum. A reference to the execution trace on which it is based. Cryptographic signatures. A DecisionEvent does not include: Free-text justification. Embedded data. Explicit timestamps. Identity of the decision-maker. Reason Codes Reason codes represent categories of justification. They are controlled, human-defined enums. They do not contain explanations themselves. Full explanations are derived from execution traces and definitional logic. Temporal Semantics A DecisionEvent does not contain an explicit timestamp. Temporal ordering is derived from: Append-only ledger position. Cryptographic signatures. Time is not stored as semantic content inside the decision itself. Section 7 : Execution & Replay Semantics (draft v1) Execution Model System execution is represented as a sequence of immutable execution traces. Each ExecutionTrace represents a single step or transition in a decision process. Execution is append-only and strictly ordered by causal links between traces. Trace Immutability Each ExecutionTrace: Is created once. Is never modified. Is never deleted. References the previous trace in the process. There is no single growing or mutable trace object. The full execution history is the chain of trace records. Replay Semantics Replay is purely logical and internal. Its purpose is to reconstruct: What the system believed. What decisions were made. How those decisions were reached. Replay must never: Re-trigger external actions. Cause any real-world side effects. Modify system state. Escalation Semantics Escalations are first-class governed processes. An escalation is represented by an EscalationRecord, which includes: The trigger trace. The escalation rule used. The assigned human authorities. The human resolution. The resulting decision event. The resolution trace. Escalations are not mere notifications. They are authoritative decision processes with recorded outcomes. Causal Consistency All execution traces, decisions, and escalations must form a causally consistent graph. No cycles are permitted. Section 8 : Intent & Process Model (draft v1) Intent Context An IntentContext represents a single decision process instance. It is a snapshot of all relevant state for that process. Once a decision process starts, its IntentContext is frozen. No mid-flight input may mutate it. Snapshot Isolation If new information arrives while a decision is pending: Either a new decision process is spawned with a new IntentContext, or The current process is aborted and restarted. Inputs are never merged into an active context. Intent Skeleton An IntentSkeleton defines the executable behavioral template for a class of processes. It specifies: Default stages. Allowed transitions. Linked decision points. Linked preconditions. Linked escalation rules. An IntentSkeleton is not merely a static ontology. It is a starter program for how an intent should be processed. Process Determinism Intent processing is fully deterministic. Given the same IntentSkeleton and the same IntentContext, the system must always produce the same sequence of traces and decisions. Task Semantics A task is a notification or instruction issued to a human. Tasks are not first-class entities with their own lifecycle. The system records that a task was issued and to whom. Task execution is reflected only through subsequent human decisions or actions. Section 9 : Change & Evolution Model (draft v1) Non-Retroactivity System logic changes must never retroactively affect past decisions. Every decision is evaluated only against the exact logic version that existed at the time the decision process started. ChangeSet Mechanism All changes to definitional logic must be proposed and compiled into a ChangeSet artifact. The runtime system ingests and applies only ChangeSets. Direct mutation of core definitions is forbidden. Human Approval Each ChangeSet requires explicit human approval before application. Automatic application is not allowed. Single Active Version At any given time, there is exactly one active version of system schemas and logic. Old versions are preserved only for historical reference and replay. Multiple active logic versions may not coexist at runtime. Immutable History Past definitions are never deleted. They remain in the registry as historical truth. System evolution is fully auditable. Section 10 : Security & Threat Model (draft v1) Threat Model The system assumes the presence of: External attackers. Malicious insiders. Faulty or compromised internal components. Multiple insiders colluding. No internal actor is inherently trusted. Auditability All actions in the system must be: Recorded. Cryptographically verifiable. Fully auditable. No action may occur without leaving an immutable trace. Tamper Detection Tampering with any canonical record must be detectable. Record identity and integrity are cryptographically bound. Replay does not require trusting storage. Fail-Closed Principle If the system cannot establish: Consistent registry state, or Valid authority, or Valid cryptographic verification, It must fail closed and stop processing. No Silent Authority No human or system component may perform authoritative actions without being recorded and signed. There is no concept of implicit trust. All authority is explicit and auditable. Section 11 \u2014 Deployment & Operational Model (draft v1) 1. Physical Distribution The system is physically distributed across multiple independent replicas. Each replica runs as a separate program or process. There is no single monolithic system instance. Logical Singularity Despite physical distribution, the system behaves as a logically single entity. All replicas must agree on all canonical records. There is exactly one authoritative system state. Consensus Requirement The system uses strong consensus with unanimous agreement. A record is considered valid only if all replicas explicitly agree. Temporary forks or divergent truths are not permitted. Failure Semantics If replicas: Diverge, Disagree, or Cannot reach unanimous consensus, The system must stop processing and wait until consistency is restored. Availability is always secondary to correctness. Operational Records Operational events, both human and system-generated, are recorded as OperationalRecords. These records are first-class, immutable, and auditable. They are subject to the same cryptographic and consensus guarantees as all other canonical records. Section 12 : Global Invariants (draft v1) Determinism Invariant For any given input and logic version, the system must always produce the same sequence of execution traces and decisions. No nondeterministic behavior is permitted. Authority Invariant No authoritative outcome may be produced without explicit human-defined logic and, where required, explicit human approval. AI components may never act as autonomous authorities. Non-Retroactivity Invariant Past decisions must never be re-evaluated or altered by future logic changes. Historical truth is immutable. Identity Invariant All actions must be attributable to verified system identities. Anonymous authority is forbidden. Content-Derived Identity Invariant Every canonical record must have a content-derived cryptographic identity. Any change to content must result in a different identity. Fail-Closed Invariant If any core invariant cannot be enforced, the system must stop processing. Partial correctness is forbidden.","title":"Architecture v1"},{"location":"axioms/","text":"Axioms Foundational Axioms of the Governance System Axiom 1 : Determinism For any given input and logic version, the system must always produce the same sequence of execution traces and decisions. No nondeterministic behavior is permitted. Axiom 2 : Human Authority All authority originates from humans. No internal component, automated process, or AI system is ever an authority. The system may evaluate and enforce logic, but it never originates authority. Axiom 3 : Explicit Logic Only The system may only apply logic that has been explicitly authored and approved by humans. The system must never infer, optimize, or invent outcomes. If no deterministic outcome exists, the system must escalate to humans. Axiom 4 : Immutable History All canonical records are immutable. Past decisions, traces, and definitions must never be modified or deleted. Historical truth is permanent. Axiom 5 : Non-Retroactivity System logic changes must never retroactively affect past decisions. Every decision is evaluated only against the logic version that existed when its process started. Axiom 6 : Content-Derived Identity Every canonical record has a content-derived cryptographic identity. Any change to content produces a different identity. Tampering is always detectable. Axiom 7 : Closed Ontology Only explicitly defined entity and record types may exist in the system. No implicit, dynamic, or ad-hoc types are permitted. Axiom 8 : Append-Only Truth All system evolution occurs by appending new records. No record may ever be overwritten or erased. Axiom 9 : Full Auditability All actions in the system must leave an immutable, verifiable trace. No silent or hidden authority is permitted. Axiom 10 : Fail-Closed If the system cannot establish: valid authority, valid logic, or consistent truth, it must stop processing. Partial correctness is forbidden.","title":"Axioms"},{"location":"axioms/#axioms","text":"Foundational Axioms of the Governance System Axiom 1 : Determinism For any given input and logic version, the system must always produce the same sequence of execution traces and decisions. No nondeterministic behavior is permitted. Axiom 2 : Human Authority All authority originates from humans. No internal component, automated process, or AI system is ever an authority. The system may evaluate and enforce logic, but it never originates authority. Axiom 3 : Explicit Logic Only The system may only apply logic that has been explicitly authored and approved by humans. The system must never infer, optimize, or invent outcomes. If no deterministic outcome exists, the system must escalate to humans. Axiom 4 : Immutable History All canonical records are immutable. Past decisions, traces, and definitions must never be modified or deleted. Historical truth is permanent. Axiom 5 : Non-Retroactivity System logic changes must never retroactively affect past decisions. Every decision is evaluated only against the logic version that existed when its process started. Axiom 6 : Content-Derived Identity Every canonical record has a content-derived cryptographic identity. Any change to content produces a different identity. Tampering is always detectable. Axiom 7 : Closed Ontology Only explicitly defined entity and record types may exist in the system. No implicit, dynamic, or ad-hoc types are permitted. Axiom 8 : Append-Only Truth All system evolution occurs by appending new records. No record may ever be overwritten or erased. Axiom 9 : Full Auditability All actions in the system must leave an immutable, verifiable trace. No silent or hidden authority is permitted. Axiom 10 : Fail-Closed If the system cannot establish: valid authority, valid logic, or consistent truth, it must stop processing. Partial correctness is forbidden.","title":"Axioms"},{"location":"contact/","text":"Contact the Builder This project is not a product. It is a long-term institutional research and governance initiative. The builder is the original architect of the system and acts as: system founder constitutional author research lead Contact is intended for serious, aligned use cases only . Who should contact You should reach out if you are: building governance, compliance, or decision systems working in AI safety, policy, or regulation leading enterprise risk or security an investor exploring governance infrastructure a researcher interested in deterministic systems This is not for: sales pitches recruitment spam generic networking Why contact Valid reasons to contact include: discussing real-world deployment collaborating on governance frameworks contributing research or standards work institutional partnerships legal or policy applications How to contact Primary channel (recommended) Email: pavan@deterministicgovernance.org Professional profiles LinkedIn: https://www.linkedin.com/in/pavancharak/ Project Website: https://www.deterministicgovernance.org/ Communication principles All communication should follow the same principles as the system: explicit reasoned accountable purpose-driven Unstructured or vague outreach will be ignored. Note This project is intentionally slow, deliberate, and non-commercial by default. The goal is not growth. The goal is correct governance .","title":"Contact"},{"location":"contact/#contact-the-builder","text":"This project is not a product. It is a long-term institutional research and governance initiative. The builder is the original architect of the system and acts as: system founder constitutional author research lead Contact is intended for serious, aligned use cases only .","title":"Contact the Builder"},{"location":"contact/#who-should-contact","text":"You should reach out if you are: building governance, compliance, or decision systems working in AI safety, policy, or regulation leading enterprise risk or security an investor exploring governance infrastructure a researcher interested in deterministic systems This is not for: sales pitches recruitment spam generic networking","title":"Who should contact"},{"location":"contact/#why-contact","text":"Valid reasons to contact include: discussing real-world deployment collaborating on governance frameworks contributing research or standards work institutional partnerships legal or policy applications","title":"Why contact"},{"location":"contact/#how-to-contact","text":"","title":"How to contact"},{"location":"contact/#primary-channel-recommended","text":"Email: pavan@deterministicgovernance.org","title":"Primary channel (recommended)"},{"location":"contact/#professional-profiles","text":"LinkedIn: https://www.linkedin.com/in/pavancharak/ Project Website: https://www.deterministicgovernance.org/","title":"Professional profiles"},{"location":"contact/#communication-principles","text":"All communication should follow the same principles as the system: explicit reasoned accountable purpose-driven Unstructured or vague outreach will be ignored.","title":"Communication principles"},{"location":"contact/#note","text":"This project is intentionally slow, deliberate, and non-commercial by default. The goal is not growth. The goal is correct governance .","title":"Note"},{"location":"engine/","text":"Engine Execution & Decision Engine Semantics Engine Role The Decision Engine is an orchestrator. It evaluates logic, produces execution traces, and triggers record creation. It is not a source of truth. It must never write canonical records directly. All canonical record creation occurs via the Registry Engine. Execution Model System execution is represented as a sequence of immutable ExecutionTraces. Each ExecutionTrace represents a single step or transition in a decision process. Execution is append-only and strictly ordered by causal links. There is no mutable global state. Intent Processing Each process begins with creation of an IntentContext. The IntentContext is a frozen snapshot of all relevant input. Once created: It cannot be modified. New inputs cannot be merged. Mid-flight changes require new processes. Deterministic Evaluation For any given IntentContext and logic version: The same execution traces must be produced. The same decisions must be produced. The engine must never: Infer missing logic. Optimize behavior. Invent outcomes. If deterministic evaluation is impossible, the engine must escalate. Decision Emission When a decision point is reached: The engine selects exactly one outcome. A DecisionEvent is produced. A reason code is attached. The decision references the final execution trace. There is no distinction between intermediate and final decisions. Replay Semantics Replay is purely logical and internal. Its purpose is to reconstruct: What the system believed. What steps occurred. How decisions were derived. Replay must never: Trigger external actions. Cause side effects. Modify system state. Failure Semantics If the engine cannot establish: Valid logic, Valid authority, Or valid registry state, It must stop processing. Partial execution is forbidden. Engine Constraints The engine must: Be deterministic. Be stateless between processes. Rely only on registry truth. Fail closed on inconsistency.","title":"Engine"},{"location":"engine/#engine","text":"Execution & Decision Engine Semantics Engine Role The Decision Engine is an orchestrator. It evaluates logic, produces execution traces, and triggers record creation. It is not a source of truth. It must never write canonical records directly. All canonical record creation occurs via the Registry Engine. Execution Model System execution is represented as a sequence of immutable ExecutionTraces. Each ExecutionTrace represents a single step or transition in a decision process. Execution is append-only and strictly ordered by causal links. There is no mutable global state. Intent Processing Each process begins with creation of an IntentContext. The IntentContext is a frozen snapshot of all relevant input. Once created: It cannot be modified. New inputs cannot be merged. Mid-flight changes require new processes. Deterministic Evaluation For any given IntentContext and logic version: The same execution traces must be produced. The same decisions must be produced. The engine must never: Infer missing logic. Optimize behavior. Invent outcomes. If deterministic evaluation is impossible, the engine must escalate. Decision Emission When a decision point is reached: The engine selects exactly one outcome. A DecisionEvent is produced. A reason code is attached. The decision references the final execution trace. There is no distinction between intermediate and final decisions. Replay Semantics Replay is purely logical and internal. Its purpose is to reconstruct: What the system believed. What steps occurred. How decisions were derived. Replay must never: Trigger external actions. Cause side effects. Modify system state. Failure Semantics If the engine cannot establish: Valid logic, Valid authority, Or valid registry state, It must stop processing. Partial execution is forbidden. Engine Constraints The engine must: Be deterministic. Be stateless between processes. Rely only on registry truth. Fail closed on inconsistency.","title":"Engine"},{"location":"escalation/","text":"Escalation Human Escalation & Authority Semantics Purpose of Escalation Escalation exists to handle cases where: Deterministic logic cannot derive an outcome. Human judgment is explicitly required. Authority must be exercised outside predefined rules. Escalation is not an error state. It is a first-class governed decision process. Escalation Trigger Escalation occurs when: A Precondition cannot be evaluated deterministically, or An EscalationRule\u2019s trigger_condition evaluates to true. The Decision Engine must never guess or approximate outcomes. If logic is insufficient, escalation is mandatory. Escalation Rule An EscalationRule defines: When escalation is triggered. Which human role(s) must be involved. Escalation rules are deterministic and human-authored. They are part of the system\u2019s definitional logic. Escalation Process When escalation is triggered: An EscalationRecord is created. Assigned humans are notified. Humans review the context and execution traces. A human resolution is provided. A resolution ExecutionTrace is created. A DecisionEvent is emitted based on the human outcome. The entire escalation lifecycle is recorded immutably. Human Authority Human participants in escalation: Are verified system identities. Must cryptographically sign their actions. Are fully auditable and non-repudiable. Human resolution is authoritative. The system may not override or reinterpret it. No Silent Escalation All escalations must be explicit. There is no concept of: Implicit human approval. Default fallback authority. Silent overrides. If a human decision occurs, it must be recorded. Escalation as Governance Escalation is not a workaround. It is the formal mechanism by which: The system remains safe. Responsibility remains human. Automation remains bounded. Escalation is the system\u2019s legal interface with reality.","title":"Escalation"},{"location":"escalation/#escalation","text":"Human Escalation & Authority Semantics Purpose of Escalation Escalation exists to handle cases where: Deterministic logic cannot derive an outcome. Human judgment is explicitly required. Authority must be exercised outside predefined rules. Escalation is not an error state. It is a first-class governed decision process. Escalation Trigger Escalation occurs when: A Precondition cannot be evaluated deterministically, or An EscalationRule\u2019s trigger_condition evaluates to true. The Decision Engine must never guess or approximate outcomes. If logic is insufficient, escalation is mandatory. Escalation Rule An EscalationRule defines: When escalation is triggered. Which human role(s) must be involved. Escalation rules are deterministic and human-authored. They are part of the system\u2019s definitional logic. Escalation Process When escalation is triggered: An EscalationRecord is created. Assigned humans are notified. Humans review the context and execution traces. A human resolution is provided. A resolution ExecutionTrace is created. A DecisionEvent is emitted based on the human outcome. The entire escalation lifecycle is recorded immutably. Human Authority Human participants in escalation: Are verified system identities. Must cryptographically sign their actions. Are fully auditable and non-repudiable. Human resolution is authoritative. The system may not override or reinterpret it. No Silent Escalation All escalations must be explicit. There is no concept of: Implicit human approval. Default fallback authority. Silent overrides. If a human decision occurs, it must be recorded. Escalation as Governance Escalation is not a workaround. It is the formal mechanism by which: The system remains safe. Responsibility remains human. Automation remains bounded. Escalation is the system\u2019s legal interface with reality.","title":"Escalation"},{"location":"examples_v1/","text":"Examples v1 Example Execution Traces for architecture_v1 Example 1 : Simple Deterministic Decision Scenario A system evaluates whether an action is permitted. IntentSkeleton Name: \"PermissionCheck\" IntentContext Input: - actor_id = Human_123 - action = \"ACCESS_RESOURCE\" Execution ExecutionTrace T1: System evaluates Precondition \"IsActorAuthenticated\" \u2192 true ExecutionTrace T2: System evaluates Precondition \"HasPermission\" \u2192 true DecisionEvent D1: decision_point = \"PermissionDecision\" outcome = \"ALLOW\" reason_code = \"ALL_PRECONDITIONS_TRUE\" based_on_trace = T2 Result Access is granted. No escalation occurs. Example 2 : Escalation Required Scenario A system cannot derive deterministic outcome. IntentSkeleton Name: \"FinancialApproval\" IntentContext Input: - amount = 1,000,000 - requester = Human_456 Execution ExecutionTrace T1: System evaluates Precondition \"AmountBelowLimit\" \u2192 false EscalationRecord E1: triggered_by = T1 escalation_rule = \"HighValueRequiresHuman\" assigned_humans = [Human_Admin] Human_Admin approves. ExecutionTrace T2: Human resolution recorded. DecisionEvent D1: decision_point = \"ApprovalDecision\" outcome = \"APPROVED\" reason_code = \"HUMAN_ESCALATION\" based_on_trace = T2 Result Decision produced via escalation. Example 3 : Snapshot Isolation Scenario New input arrives mid-decision. Execution IntentContext C1 created. ExecutionTrace T1 occurs. New input arrives. System behavior: - C1 remains unchanged. - New IntentContext C2 is created. C1 and C2 are evaluated independently.","title":"Examples"},{"location":"examples_v1/#examples-v1","text":"Example Execution Traces for architecture_v1","title":"Examples v1"},{"location":"examples_v1/#example-1-simple-deterministic-decision","text":"","title":"Example 1 : Simple Deterministic Decision"},{"location":"examples_v1/#scenario","text":"A system evaluates whether an action is permitted.","title":"Scenario"},{"location":"examples_v1/#intentskeleton","text":"Name: \"PermissionCheck\"","title":"IntentSkeleton"},{"location":"examples_v1/#intentcontext","text":"Input: - actor_id = Human_123 - action = \"ACCESS_RESOURCE\"","title":"IntentContext"},{"location":"examples_v1/#execution","text":"ExecutionTrace T1: System evaluates Precondition \"IsActorAuthenticated\" \u2192 true ExecutionTrace T2: System evaluates Precondition \"HasPermission\" \u2192 true DecisionEvent D1: decision_point = \"PermissionDecision\" outcome = \"ALLOW\" reason_code = \"ALL_PRECONDITIONS_TRUE\" based_on_trace = T2","title":"Execution"},{"location":"examples_v1/#result","text":"Access is granted. No escalation occurs.","title":"Result"},{"location":"examples_v1/#example-2-escalation-required","text":"","title":"Example 2 : Escalation Required"},{"location":"examples_v1/#scenario_1","text":"A system cannot derive deterministic outcome.","title":"Scenario"},{"location":"examples_v1/#intentskeleton_1","text":"Name: \"FinancialApproval\"","title":"IntentSkeleton"},{"location":"examples_v1/#intentcontext_1","text":"Input: - amount = 1,000,000 - requester = Human_456","title":"IntentContext"},{"location":"examples_v1/#execution_1","text":"ExecutionTrace T1: System evaluates Precondition \"AmountBelowLimit\" \u2192 false EscalationRecord E1: triggered_by = T1 escalation_rule = \"HighValueRequiresHuman\" assigned_humans = [Human_Admin] Human_Admin approves. ExecutionTrace T2: Human resolution recorded. DecisionEvent D1: decision_point = \"ApprovalDecision\" outcome = \"APPROVED\" reason_code = \"HUMAN_ESCALATION\" based_on_trace = T2","title":"Execution"},{"location":"examples_v1/#result_1","text":"Decision produced via escalation.","title":"Result"},{"location":"examples_v1/#example-3-snapshot-isolation","text":"","title":"Example 3 : Snapshot Isolation"},{"location":"examples_v1/#scenario_2","text":"New input arrives mid-decision.","title":"Scenario"},{"location":"examples_v1/#execution_2","text":"IntentContext C1 created. ExecutionTrace T1 occurs. New input arrives. System behavior: - C1 remains unchanged. - New IntentContext C2 is created. C1 and C2 are evaluated independently.","title":"Execution"},{"location":"glossary/","text":"Glossary This glossary defines all canonical terms used in the governance system. All terms are precise and non-interchangeable. DecisionPoint A formally defined location in a process where a decision must occur. DecisionPoints define the finite set of allowed outcomes. DecisionEvent A canonical record representing the authoritative outcome of a DecisionPoint. DecisionEvents are immutable and content-hash identified. ExecutionTrace An immutable record of a single step or transition in a process. ExecutionTraces form a causal chain. Escalation A governed transfer of authority to humans when logic is insufficient. EscalationRecord A record representing the full lifecycle of an escalation, including trigger, assigned humans, and resolution. ChangeSet A human-approved modification to system logic. All system evolution occurs only through ChangeSets. Precondition A pure boolean predicate over IntentContext. Preconditions have no side effects. IntentSkeleton An executable template defining the structure of a class of intents. Registry The append-only canonical store of all records. The single source of truth. Determinism The property that identical inputs always produce identical outcomes. Fail Closed The rule that the system must stop operating if consistency cannot be guaranteed.","title":"Glossary"},{"location":"glossary/#glossary","text":"This glossary defines all canonical terms used in the governance system. All terms are precise and non-interchangeable.","title":"Glossary"},{"location":"glossary/#decisionpoint","text":"A formally defined location in a process where a decision must occur. DecisionPoints define the finite set of allowed outcomes.","title":"DecisionPoint"},{"location":"glossary/#decisionevent","text":"A canonical record representing the authoritative outcome of a DecisionPoint. DecisionEvents are immutable and content-hash identified.","title":"DecisionEvent"},{"location":"glossary/#executiontrace","text":"An immutable record of a single step or transition in a process. ExecutionTraces form a causal chain.","title":"ExecutionTrace"},{"location":"glossary/#escalation","text":"A governed transfer of authority to humans when logic is insufficient.","title":"Escalation"},{"location":"glossary/#escalationrecord","text":"A record representing the full lifecycle of an escalation, including trigger, assigned humans, and resolution.","title":"EscalationRecord"},{"location":"glossary/#changeset","text":"A human-approved modification to system logic. All system evolution occurs only through ChangeSets.","title":"ChangeSet"},{"location":"glossary/#precondition","text":"A pure boolean predicate over IntentContext. Preconditions have no side effects.","title":"Precondition"},{"location":"glossary/#intentskeleton","text":"An executable template defining the structure of a class of intents.","title":"IntentSkeleton"},{"location":"glossary/#registry","text":"The append-only canonical store of all records. The single source of truth.","title":"Registry"},{"location":"glossary/#determinism","text":"The property that identical inputs always produce identical outcomes.","title":"Determinism"},{"location":"glossary/#fail-closed","text":"The rule that the system must stop operating if consistency cannot be guaranteed.","title":"Fail Closed"},{"location":"governance_principles/","text":"Governance Principles These principles define how the system must behave at all times. They are higher-level than axioms and guide all design decisions. 1. Explicit Over Implicit All system behavior must be explicitly defined by humans. No hidden inference or emergent logic is allowed. 2. Human Judgment Over Automation Automation may assist, but never replace, human authority. 3. Determinism Over Optimization Correctness and reproducibility take precedence over efficiency. 4. Auditability Over Performance Every action must be traceable and explainable. 5. Stability Over Innovation System evolution is slow, deliberate, and conservative. 6. Explanation Over Opacity Every outcome must be explainable from recorded logic. 7. Law Over Learning The system follows written rules, not learned behavior. 8. Fail Closed By Default On ambiguity, inconsistency, or missing logic, the system must halt and escalate. 9. No Silent Drift System behavior must never change without a ChangeSet. 10. Authority Is Always Provable All decisions must be cryptographically attributable.","title":"Principles"},{"location":"governance_principles/#governance-principles","text":"These principles define how the system must behave at all times. They are higher-level than axioms and guide all design decisions.","title":"Governance Principles"},{"location":"governance_principles/#1-explicit-over-implicit","text":"All system behavior must be explicitly defined by humans. No hidden inference or emergent logic is allowed.","title":"1. Explicit Over Implicit"},{"location":"governance_principles/#2-human-judgment-over-automation","text":"Automation may assist, but never replace, human authority.","title":"2. Human Judgment Over Automation"},{"location":"governance_principles/#3-determinism-over-optimization","text":"Correctness and reproducibility take precedence over efficiency.","title":"3. Determinism Over Optimization"},{"location":"governance_principles/#4-auditability-over-performance","text":"Every action must be traceable and explainable.","title":"4. Auditability Over Performance"},{"location":"governance_principles/#5-stability-over-innovation","text":"System evolution is slow, deliberate, and conservative.","title":"5. Stability Over Innovation"},{"location":"governance_principles/#6-explanation-over-opacity","text":"Every outcome must be explainable from recorded logic.","title":"6. Explanation Over Opacity"},{"location":"governance_principles/#7-law-over-learning","text":"The system follows written rules, not learned behavior.","title":"7. Law Over Learning"},{"location":"governance_principles/#8-fail-closed-by-default","text":"On ambiguity, inconsistency, or missing logic, the system must halt and escalate.","title":"8. Fail Closed By Default"},{"location":"governance_principles/#9-no-silent-drift","text":"System behavior must never change without a ChangeSet.","title":"9. No Silent Drift"},{"location":"governance_principles/#10-authority-is-always-provable","text":"All decisions must be cryptographically attributable.","title":"10. Authority Is Always Provable"},{"location":"newsletter/","text":"How to Subscribe The official newsletter is hosted on Substack. Subscribe here: https://deterministicgovernance.substack.com/","title":"Newsletter"},{"location":"newsletter/#how-to-subscribe","text":"The official newsletter is hosted on Substack. Subscribe here: https://deterministicgovernance.substack.com/","title":"How to Subscribe"},{"location":"ontology/","text":"Ontology Core Ontology of the Governance System Ontological Scope The system defines a closed and explicit ontology of internal entities. Only entities defined within this ontology are permitted to exist inside the system. No implicit, dynamic, or ad-hoc entity types are allowed. All entities are: First-class. Explicitly typed. Immutable once created. Identified by content-derived cryptographic identity. Fundamental Classes The system\u2019s ontology consists of two fundamental classes: 2.1 Factual Entities Factual entities represent what actually happened. They include: Decisions made by the system. Execution steps taken during a process. Escalations and their resolutions. Operational events. Factual entities are historical truth. They are never edited, never deleted, and never reinterpreted. 2.2 Definitional Entities Definitional entities represent the logic that governs system behavior. They include: Decision points. Preconditions. Escalation rules. Intent skeletons. Record schemas. Definitional entities determine how future decisions may be evaluated. They do not retroactively affect past factual entities. Ontology Closure Principle The set of entity types in the system is strictly limited and closed. No new fundamental entity types may be introduced dynamically. Changes to the ontology itself require the same human-approved change process as any other core logic change. Dual-Truth Principle The system treats both: Facts (what happened), and Process traces (how it happened) as equally real and first-class. Neither is derived from the other. Both are stored explicitly, immutably, and independently. Identity Principle Every entity in the system has a content-derived cryptographic identity. The identity is computed as a hash of the canonical serialization of the entity\u2019s contents. Any change to content produces a different identity. Tampering is detectable at the object level. Replay does not require trusting storage.","title":"Ontology"},{"location":"ontology/#ontology","text":"Core Ontology of the Governance System Ontological Scope The system defines a closed and explicit ontology of internal entities. Only entities defined within this ontology are permitted to exist inside the system. No implicit, dynamic, or ad-hoc entity types are allowed. All entities are: First-class. Explicitly typed. Immutable once created. Identified by content-derived cryptographic identity. Fundamental Classes The system\u2019s ontology consists of two fundamental classes: 2.1 Factual Entities Factual entities represent what actually happened. They include: Decisions made by the system. Execution steps taken during a process. Escalations and their resolutions. Operational events. Factual entities are historical truth. They are never edited, never deleted, and never reinterpreted. 2.2 Definitional Entities Definitional entities represent the logic that governs system behavior. They include: Decision points. Preconditions. Escalation rules. Intent skeletons. Record schemas. Definitional entities determine how future decisions may be evaluated. They do not retroactively affect past factual entities. Ontology Closure Principle The set of entity types in the system is strictly limited and closed. No new fundamental entity types may be introduced dynamically. Changes to the ontology itself require the same human-approved change process as any other core logic change. Dual-Truth Principle The system treats both: Facts (what happened), and Process traces (how it happened) as equally real and first-class. Neither is derived from the other. Both are stored explicitly, immutably, and independently. Identity Principle Every entity in the system has a content-derived cryptographic identity. The identity is computed as a hash of the canonical serialization of the entity\u2019s contents. Any change to content produces a different identity. Tampering is detectable at the object level. Replay does not require trusting storage.","title":"Ontology"},{"location":"records/","text":"Records Canonical Record Types 1. Closed Set Principle The system defines a strictly limited and closed set of canonical record types. Only these record types are permitted to exist in the registry. No new fundamental record types may be introduced dynamically. Changes to the set of record types require explicit human approval via ChangeSets. 2. Factual Record Types These records represent what actually happened. 2.1 DecisionEvent Represents an authoritative decision. Fields: - decision_point_id : Hash - intent_context_id : Hash - outcome : Enum - reason_code : Enum - based_on_trace_id : Hash - signatures : List Properties: - No free-text fields. - No timestamps. - No decider identity. - Immutable and append-only. 2.2 ExecutionTrace Represents a single step in a decision process. Fields: - intent_context_id : Hash - trace_type : Enum - subject_id : Hash - previous_trace_id : Hash | null - resulting_context_id : Hash - signatures : List Properties: - Each trace references the previous. - No cycles allowed. - Entire history is the chain. 2.3 EscalationRecord Represents a governed human escalation. Fields: - trigger_trace_id : Hash - escalation_rule_id : Hash - assigned_humans : List - resolution_decision_event_id : Hash - resolution_trace_id : Hash - signatures : List Properties: - Records full escalation lifecycle. - First-class authoritative process. 2.4 OperationalRecord Represents operational system or human events. Fields: - operation_type : Enum - operation_actor : Enum(HUMAN|SYSTEM) - actor_identity_id : Hash - affected_components : List - operation_payload : DeterministicObject - signatures : List 3. Definitional Record Types These records define how future behavior works. 3.1 DecisionPoint Defines a place where a decision occurs. Fields: - name : String - description : String - outcomes : List - signatures : List 3.2 Precondition Defines a boolean predicate. Fields: - name : String - description : String - predicate_expression : BooleanExpression - signatures : List Properties: - Must be deterministic. - No side effects. 3.3 EscalationRule Defines when human escalation occurs. Fields: - name : String - description : String - trigger_condition : BooleanExpression - escalation_target_role : Role - signatures : List 3.4 IntentSkeleton Defines a behavioral template. Fields: - name : String - description : String - stages : List - transitions : List - signatures : List 3.5 ChangeSet Defines a change to system logic. Fields: - change_type : Enum(ADD|UPDATE|DEPRECATE) - target_record_type : Enum - target_record_id : Hash - new_definition : Record - rationale : String - approvals : List - signatures : List 4. Referential Integrity All canonical records must reference only existing canonical records. Records with invalid references are rejected. 5. Validation & Consensus A canonical record is valid only if: - Schema is valid. - References are valid. - Required signatures are present. - All replicas reach unanimous consensus.","title":"Records"},{"location":"records/#records","text":"Canonical Record Types","title":"Records"},{"location":"records/#1-closed-set-principle","text":"The system defines a strictly limited and closed set of canonical record types. Only these record types are permitted to exist in the registry. No new fundamental record types may be introduced dynamically. Changes to the set of record types require explicit human approval via ChangeSets.","title":"1. Closed Set Principle"},{"location":"records/#2-factual-record-types","text":"These records represent what actually happened.","title":"2. Factual Record Types"},{"location":"records/#21-decisionevent","text":"Represents an authoritative decision. Fields: - decision_point_id : Hash - intent_context_id : Hash - outcome : Enum - reason_code : Enum - based_on_trace_id : Hash - signatures : List Properties: - No free-text fields. - No timestamps. - No decider identity. - Immutable and append-only.","title":"2.1 DecisionEvent"},{"location":"records/#22-executiontrace","text":"Represents a single step in a decision process. Fields: - intent_context_id : Hash - trace_type : Enum - subject_id : Hash - previous_trace_id : Hash | null - resulting_context_id : Hash - signatures : List Properties: - Each trace references the previous. - No cycles allowed. - Entire history is the chain.","title":"2.2 ExecutionTrace"},{"location":"records/#23-escalationrecord","text":"Represents a governed human escalation. Fields: - trigger_trace_id : Hash - escalation_rule_id : Hash - assigned_humans : List - resolution_decision_event_id : Hash - resolution_trace_id : Hash - signatures : List Properties: - Records full escalation lifecycle. - First-class authoritative process.","title":"2.3 EscalationRecord"},{"location":"records/#24-operationalrecord","text":"Represents operational system or human events. Fields: - operation_type : Enum - operation_actor : Enum(HUMAN|SYSTEM) - actor_identity_id : Hash - affected_components : List - operation_payload : DeterministicObject - signatures : List","title":"2.4 OperationalRecord"},{"location":"records/#3-definitional-record-types","text":"These records define how future behavior works.","title":"3. Definitional Record Types"},{"location":"records/#31-decisionpoint","text":"Defines a place where a decision occurs. Fields: - name : String - description : String - outcomes : List - signatures : List","title":"3.1 DecisionPoint"},{"location":"records/#32-precondition","text":"Defines a boolean predicate. Fields: - name : String - description : String - predicate_expression : BooleanExpression - signatures : List Properties: - Must be deterministic. - No side effects.","title":"3.2 Precondition"},{"location":"records/#33-escalationrule","text":"Defines when human escalation occurs. Fields: - name : String - description : String - trigger_condition : BooleanExpression - escalation_target_role : Role - signatures : List","title":"3.3 EscalationRule"},{"location":"records/#34-intentskeleton","text":"Defines a behavioral template. Fields: - name : String - description : String - stages : List - transitions : List - signatures : List","title":"3.4 IntentSkeleton"},{"location":"records/#35-changeset","text":"Defines a change to system logic. Fields: - change_type : Enum(ADD|UPDATE|DEPRECATE) - target_record_type : Enum - target_record_id : Hash - new_definition : Record - rationale : String - approvals : List - signatures : List","title":"3.5 ChangeSet"},{"location":"records/#4-referential-integrity","text":"All canonical records must reference only existing canonical records. Records with invalid references are rejected.","title":"4. Referential Integrity"},{"location":"records/#5-validation-consensus","text":"A canonical record is valid only if: - Schema is valid. - References are valid. - Required signatures are present. - All replicas reach unanimous consensus.","title":"5. Validation &amp; Consensus"},{"location":"schemas_v1/","text":"Schemas Canonical Record Schemas for architecture_v1 DecisionEvent Fields: - decision_point_id : Hash - intent_context_id : Hash - outcome : Enum - reason_code : Enum - based_on_trace_id : Hash - signatures : List Constraints: - outcome must be allowed by DecisionPoint - no timestamp field - no free-text fields ExecutionTrace Fields: - intent_context_id : Hash - trace_type : Enum - subject_id : Hash - previous_trace_id : Hash | null - resulting_context_id : Hash - signatures : List Constraints: - no cycles - append-only EscalationRecord Fields: - trigger_trace_id : Hash - escalation_rule_id : Hash - assigned_humans : List - resolution_decision_event_id : Hash - resolution_trace_id : Hash - signatures : List DecisionPoint Fields: - name : String - description : String - outcomes : List - signatures : List Precondition Fields: - name : String - description : String - predicate_expression : BooleanExpression - signatures : List EscalationRule Fields: - name : String - description : String - trigger_condition : BooleanExpression - escalation_target_role : Role - signatures : List IntentSkeleton Fields: - name : String - description : String - stages : List - transitions : List - signatures : List ChangeSet Fields: - change_type : Enum(ADD|UPDATE|DEPRECATE) - target_record_type : Enum - target_record_id : Hash - new_definition : Record - rationale : String - approvals : List - signatures : List","title":"Schemas"},{"location":"schemas_v1/#schemas","text":"Canonical Record Schemas for architecture_v1","title":"Schemas"},{"location":"schemas_v1/#decisionevent","text":"Fields: - decision_point_id : Hash - intent_context_id : Hash - outcome : Enum - reason_code : Enum - based_on_trace_id : Hash - signatures : List Constraints: - outcome must be allowed by DecisionPoint - no timestamp field - no free-text fields","title":"DecisionEvent"},{"location":"schemas_v1/#executiontrace","text":"Fields: - intent_context_id : Hash - trace_type : Enum - subject_id : Hash - previous_trace_id : Hash | null - resulting_context_id : Hash - signatures : List Constraints: - no cycles - append-only","title":"ExecutionTrace"},{"location":"schemas_v1/#escalationrecord","text":"Fields: - trigger_trace_id : Hash - escalation_rule_id : Hash - assigned_humans : List - resolution_decision_event_id : Hash - resolution_trace_id : Hash - signatures : List","title":"EscalationRecord"},{"location":"schemas_v1/#decisionpoint","text":"Fields: - name : String - description : String - outcomes : List - signatures : List","title":"DecisionPoint"},{"location":"schemas_v1/#precondition","text":"Fields: - name : String - description : String - predicate_expression : BooleanExpression - signatures : List","title":"Precondition"},{"location":"schemas_v1/#escalationrule","text":"Fields: - name : String - description : String - trigger_condition : BooleanExpression - escalation_target_role : Role - signatures : List","title":"EscalationRule"},{"location":"schemas_v1/#intentskeleton","text":"Fields: - name : String - description : String - stages : List - transitions : List - signatures : List","title":"IntentSkeleton"},{"location":"schemas_v1/#changeset","text":"Fields: - change_type : Enum(ADD|UPDATE|DEPRECATE) - target_record_type : Enum - target_record_id : Hash - new_definition : Record - rationale : String - approvals : List - signatures : List","title":"ChangeSet"},{"location":"version_history/","text":"Version History Canonical Record Schemas for architecture_v1 DecisionEvent Fields: - decision_point_id : Hash - intent_context_id : Hash - outcome : Enum - reason_code : Enum - based_on_trace_id : Hash - signatures : List Constraints: - outcome must be allowed by DecisionPoint - no timestamp field - no free-text fields ExecutionTrace Fields: - intent_context_id : Hash - trace_type : Enum - subject_id : Hash - previous_trace_id : Hash | null - resulting_context_id : Hash - signatures : List Constraints: - no cycles - append-only EscalationRecord Fields: - trigger_trace_id : Hash - escalation_rule_id : Hash - assigned_humans : List - resolution_decision_event_id : Hash - resolution_trace_id : Hash - signatures : List DecisionPoint Fields: - name : String - description : String - outcomes : List - signatures : List Precondition Fields: - name : String - description : String - predicate_expression : BooleanExpression - signatures : List EscalationRule Fields: - name : String - description : String - trigger_condition : BooleanExpression - escalation_target_role : Role - signatures : List IntentSkeleton Fields: - name : String - description : String - stages : List - transitions : List - signatures : List ChangeSet Fields: - change_type : Enum(ADD|UPDATE|DEPRECATE) - target_record_type : Enum - target_record_id : Hash - new_definition : Record - rationale : String - approvals : List - signatures : List","title":"Version History"},{"location":"version_history/#version-history","text":"Canonical Record Schemas for architecture_v1","title":"Version History"},{"location":"version_history/#decisionevent","text":"Fields: - decision_point_id : Hash - intent_context_id : Hash - outcome : Enum - reason_code : Enum - based_on_trace_id : Hash - signatures : List Constraints: - outcome must be allowed by DecisionPoint - no timestamp field - no free-text fields","title":"DecisionEvent"},{"location":"version_history/#executiontrace","text":"Fields: - intent_context_id : Hash - trace_type : Enum - subject_id : Hash - previous_trace_id : Hash | null - resulting_context_id : Hash - signatures : List Constraints: - no cycles - append-only","title":"ExecutionTrace"},{"location":"version_history/#escalationrecord","text":"Fields: - trigger_trace_id : Hash - escalation_rule_id : Hash - assigned_humans : List - resolution_decision_event_id : Hash - resolution_trace_id : Hash - signatures : List","title":"EscalationRecord"},{"location":"version_history/#decisionpoint","text":"Fields: - name : String - description : String - outcomes : List - signatures : List","title":"DecisionPoint"},{"location":"version_history/#precondition","text":"Fields: - name : String - description : String - predicate_expression : BooleanExpression - signatures : List","title":"Precondition"},{"location":"version_history/#escalationrule","text":"Fields: - name : String - description : String - trigger_condition : BooleanExpression - escalation_target_role : Role - signatures : List","title":"EscalationRule"},{"location":"version_history/#intentskeleton","text":"Fields: - name : String - description : String - stages : List - transitions : List - signatures : List","title":"IntentSkeleton"},{"location":"version_history/#changeset","text":"Fields: - change_type : Enum(ADD|UPDATE|DEPRECATE) - target_record_type : Enum - target_record_id : Hash - new_definition : Record - rationale : String - approvals : List - signatures : List","title":"ChangeSet"},{"location":"whitepapers/","text":"Whitepapers This page contains the official research and doctrine of the Deterministic Governance Systems project. These whitepapers are not marketing material. They are formal position papers intended to define: how digital authority should work, how automated systems must be governed, and why AI must never be allowed to make unaccountable decisions. Together, they form a coherent theory of digital governance . How to use this library If you are: a founder / builder \u2192 read 1, 3, 8 a researcher / academic \u2192 read 2, 9, 5 a policy maker / regulator \u2192 read 4, 6, 11 a security / compliance leader \u2192 read 7, 5 a citizen / general reader \u2192 read 11, 1, 4 1. A Constitutional Layer for AI A Global Framework for Governing Digital Authority Who should read this: Policy makers, system architects, philosophers of technology. Why read it: This paper introduces the core idea that AI systems require a constitutional layer , just like states require constitutions. It argues that: - AI cannot be \u201caligned\u201d through training, - authority must be explicitly defined, - and governance must be structural, not behavioral. Download PDF 2. Decision as a First-Class Object A Formal Theory of Governance in Software Systems Who should read this: Computer scientists, system designers, formal methods researchers. Why read it: This paper reframes \u201cdecisions\u201d as explicit system objects that must be recorded, governed, and audited. It introduces the idea that: - decisions are more important than data, - and should be modeled as first-class entities. Download PDF 3. Designing Deterministic Systems Why AI Should Never Be Allowed to Decide Who should read this: AI engineers, startup founders, product leaders. Why read it: This paper explains why probabilistic systems are fundamentally incompatible with governance, law, and accountability. It makes the case for: - determinism over learning, - rules over models, - and explanation over prediction. Download PDF 4. Governing Automated Decisions Digital Due Process & Accountable Automation Who should read this: Regulators, compliance teams, legal professionals. Why read it: This paper translates legal concepts like: - due process, - right to explanation, - and appeal mechanisms into technical system requirements. Download PDF 5. Legal Memory for Software Why Systems Must Remember Their Own Decisions Who should read this: Security engineers, auditors, institutional architects. Why read it: This paper introduces the concept of legal memory : systems must remember not just what happened, but why it happened. It argues that: - forgetting is a security vulnerability, - and memory must be immutable and auditable. Download PDF 6. Standardizing Digital Authority Why Decision Governance Must Become a Global Technical Standard Who should read this: Standards bodies, governments, international organizations. Why read it: This paper argues that governance infrastructure must become: - a shared global standard, - not proprietary corporate logic. It compares governance to: - TCP/IP for networks, - and constitutions for states. Download PDF 7. Securing Digital Authority Threat Models for Governance Infrastructure Who should read this: Cybersecurity professionals, risk officers, security researchers. Why read it: This paper defines the threat model for governance systems: - insider attacks, - silent logic drift, - collusion, - and record tampering. It treats governance as a security problem . Download PDF 8. The Decision Backbone Why Enterprises Need Deterministic Governance Systems Who should read this: Enterprise leaders, CTOs, compliance heads. Why read it: This paper explains how large organizations lose control when decisions are embedded in opaque systems. It proposes governance as: - a core infrastructure layer, - like finance or identity. Download PDF 9. The Deterministic Decision Engine A Formal Runtime Model for Provable Governance Systems Who should read this: System architects, formal verification researchers. Why read it: This is the most technical paper. It describes the runtime architecture for implementing deterministic governance systems. Download PDF 10. The Next Infrastructure Layer Why Governance Will Become the Largest Market in the Age of AI Who should read this: Investors, strategists, founders. Why read it: This paper frames governance as the next major industry, larger than cloud, fintech, or cybersecurity. It treats governance as economic infrastructure. Download PDF 11. Who Decides for Society? Democratic Governance in the Age of AI Who should read this: Citizens, educators, philosophers, journalists. Why read it: This is the most human paper. It asks the core question: If machines run everything, who actually holds power? It is the civic entry point to the entire system. Download PDF Reading order (recommended) For most people: 1 \u2192 3 \u2192 8 \u2192 4 \u2192 11 \u2192 5 \u2192 7 \u2192 6 \u2192 9 \u2192 2 \u2192 10 This takes you from: vision \u2192 engineering \u2192 enterprise \u2192 law \u2192 society \u2192 security \u2192 theory.","title":"Whitepapers"},{"location":"whitepapers/#whitepapers","text":"This page contains the official research and doctrine of the Deterministic Governance Systems project. These whitepapers are not marketing material. They are formal position papers intended to define: how digital authority should work, how automated systems must be governed, and why AI must never be allowed to make unaccountable decisions. Together, they form a coherent theory of digital governance .","title":"Whitepapers"},{"location":"whitepapers/#how-to-use-this-library","text":"If you are: a founder / builder \u2192 read 1, 3, 8 a researcher / academic \u2192 read 2, 9, 5 a policy maker / regulator \u2192 read 4, 6, 11 a security / compliance leader \u2192 read 7, 5 a citizen / general reader \u2192 read 11, 1, 4","title":"How to use this library"},{"location":"whitepapers/#1-a-constitutional-layer-for-ai","text":"A Global Framework for Governing Digital Authority Who should read this: Policy makers, system architects, philosophers of technology. Why read it: This paper introduces the core idea that AI systems require a constitutional layer , just like states require constitutions. It argues that: - AI cannot be \u201caligned\u201d through training, - authority must be explicitly defined, - and governance must be structural, not behavioral. Download PDF","title":"1. A Constitutional Layer for AI"},{"location":"whitepapers/#2-decision-as-a-first-class-object","text":"A Formal Theory of Governance in Software Systems Who should read this: Computer scientists, system designers, formal methods researchers. Why read it: This paper reframes \u201cdecisions\u201d as explicit system objects that must be recorded, governed, and audited. It introduces the idea that: - decisions are more important than data, - and should be modeled as first-class entities. Download PDF","title":"2. Decision as a First-Class Object"},{"location":"whitepapers/#3-designing-deterministic-systems","text":"Why AI Should Never Be Allowed to Decide Who should read this: AI engineers, startup founders, product leaders. Why read it: This paper explains why probabilistic systems are fundamentally incompatible with governance, law, and accountability. It makes the case for: - determinism over learning, - rules over models, - and explanation over prediction. Download PDF","title":"3. Designing Deterministic Systems"},{"location":"whitepapers/#4-governing-automated-decisions","text":"Digital Due Process & Accountable Automation Who should read this: Regulators, compliance teams, legal professionals. Why read it: This paper translates legal concepts like: - due process, - right to explanation, - and appeal mechanisms into technical system requirements. Download PDF","title":"4. Governing Automated Decisions"},{"location":"whitepapers/#5-legal-memory-for-software","text":"Why Systems Must Remember Their Own Decisions Who should read this: Security engineers, auditors, institutional architects. Why read it: This paper introduces the concept of legal memory : systems must remember not just what happened, but why it happened. It argues that: - forgetting is a security vulnerability, - and memory must be immutable and auditable. Download PDF","title":"5. Legal Memory for Software"},{"location":"whitepapers/#6-standardizing-digital-authority","text":"Why Decision Governance Must Become a Global Technical Standard Who should read this: Standards bodies, governments, international organizations. Why read it: This paper argues that governance infrastructure must become: - a shared global standard, - not proprietary corporate logic. It compares governance to: - TCP/IP for networks, - and constitutions for states. Download PDF","title":"6. Standardizing Digital Authority"},{"location":"whitepapers/#7-securing-digital-authority","text":"Threat Models for Governance Infrastructure Who should read this: Cybersecurity professionals, risk officers, security researchers. Why read it: This paper defines the threat model for governance systems: - insider attacks, - silent logic drift, - collusion, - and record tampering. It treats governance as a security problem . Download PDF","title":"7. Securing Digital Authority"},{"location":"whitepapers/#8-the-decision-backbone","text":"Why Enterprises Need Deterministic Governance Systems Who should read this: Enterprise leaders, CTOs, compliance heads. Why read it: This paper explains how large organizations lose control when decisions are embedded in opaque systems. It proposes governance as: - a core infrastructure layer, - like finance or identity. Download PDF","title":"8. The Decision Backbone"},{"location":"whitepapers/#9-the-deterministic-decision-engine","text":"A Formal Runtime Model for Provable Governance Systems Who should read this: System architects, formal verification researchers. Why read it: This is the most technical paper. It describes the runtime architecture for implementing deterministic governance systems. Download PDF","title":"9. The Deterministic Decision Engine"},{"location":"whitepapers/#10-the-next-infrastructure-layer","text":"Why Governance Will Become the Largest Market in the Age of AI Who should read this: Investors, strategists, founders. Why read it: This paper frames governance as the next major industry, larger than cloud, fintech, or cybersecurity. It treats governance as economic infrastructure. Download PDF","title":"10. The Next Infrastructure Layer"},{"location":"whitepapers/#11-who-decides-for-society","text":"Democratic Governance in the Age of AI Who should read this: Citizens, educators, philosophers, journalists. Why read it: This is the most human paper. It asks the core question: If machines run everything, who actually holds power? It is the civic entry point to the entire system. Download PDF","title":"11. Who Decides for Society?"},{"location":"whitepapers/#reading-order-recommended","text":"For most people: 1 \u2192 3 \u2192 8 \u2192 4 \u2192 11 \u2192 5 \u2192 7 \u2192 6 \u2192 9 \u2192 2 \u2192 10 This takes you from: vision \u2192 engineering \u2192 enterprise \u2192 law \u2192 society \u2192 security \u2192 theory.","title":"Reading order (recommended)"}]}